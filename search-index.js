var N=null,E="",T="t",U="u",searchIndex={};
var R=["lazy_static","mutexguard","Creates a new spinlock wrapping the supplied data.","into_inner","option","rwlockreadguard","rwlockwriteguard","formatter","result","default","deref_mut","MutexGuard","RwLockReadGuard","RwLockWriteGuard","stats_alloc","Returns the difference between the currently reported…","try_from","borrow_mut","try_into","type_id","statsalloc","StatsAlloc","An instrumenting middleware for global allocators in Rust,…","An instrumenting middleware which keeps track of…","Allocator statistics","allocations","Count of allocation operations","deallocations","Count of deallocation operations","reallocations","Count of reallocation operations","bytes_allocated","Total bytes requested by allocations","bytes_deallocated","Total bytes freed by deallocations","bytes_reallocated","Total of bytes requested minus bytes freed by reallocations","A snapshot of the allocation statistics, which can be used…","INSTRUMENTED_SYSTEM","An instrumented instance of the system allocator.","Provides access to an instrumented instance of the system…","Provides access to an instrumented instance of the given…","Takes a snapshot of the current view of the allocator…","Creates a new region using statistics from the given…","Returns the statistics as of instantiation or the last…","change_and_reset","Resets the initial initial to the latest reported…","to_owned","clone_into","borrow","typeid","sub_assign","alloc_zeroed"];
searchIndex["spin"]={"doc":"Synchronization primitives based on spinning","items":[[3,"Mutex","spin","This type provides MUTual EXclusion based on spinning.",N,N],[3,R[11],E,"A guard to which the protected data can be accessed",N,N],[3,"RwLock",E,"A reader-writer lock",N,N],[3,R[12],E,"A guard to which the protected data can be read",N,N],[3,R[13],E,"A guard to which the protected data can be written",N,N],[3,"Once",E,"A synchronization primitive which can be used to run a one-time global initialization. Unlike its std equivalent, this is generalized so that The closure returns a value and it is stored. Once therefore acts something like 1a future, too.",N,N],[11,"new",E,R[2],0,[[[T]],["mutex"]]],[11,R[3],E,"Consumes this mutex, returning the underlying data.",0,[[["self"]],[T]]],[11,"lock",E,"Locks the spinlock and returns a guard.",0,[[["self"]],[R[1]]]],[11,"force_unlock",E,"Force unlock the spinlock.",0,[[["self"]]]],[11,"try_lock",E,"Tries to lock the mutex. If it is already locked, it will return None. Otherwise it returns a guard within Some.",0,[[["self"]],[R[4],[R[1]]]]],[11,"fmt",E,E,0,[[["self"],[R[7]]],[R[8]]]],[11,R[9],E,E,0,[[],["mutex"]]],[11,"deref",E,E,1,[[["self"]],[T]]],[11,R[10],E,E,1,[[["self"]],[T]]],[11,"drop",E,"The dropping of the MutexGuard will release the lock it was created from.",1,[[["self"]]]],[11,"new",E,R[2],2,[[[T]],["rwlock"]]],[11,R[3],E,"Consumes this `RwLock`, returning the underlying data.",2,[[["self"]],[T]]],[11,"read",E,"Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",2,[[["self"]],[R[5]]]],[11,"try_read",E,"Attempt to acquire this lock with shared read access.",2,[[["self"]],[R[4],[R[5]]]]],[11,"force_read_decrement",E,"Force decrement the reader count.",2,[[["self"]]]],[11,"force_write_unlock",E,"Force unlock exclusive write access.",2,[[["self"]]]],[11,"write",E,"Lock this rwlock with exclusive write access, blocking the current thread until it can be acquired.",2,[[["self"]],[R[6]]]],[11,"try_write",E,"Attempt to lock this rwlock with exclusive write access.",2,[[["self"]],[R[4],[R[6]]]]],[11,"fmt",E,E,2,[[["self"],[R[7]]],[R[8]]]],[11,R[9],E,E,2,[[],["rwlock"]]],[11,"deref",E,E,3,[[["self"]],[T]]],[11,"deref",E,E,4,[[["self"]],[T]]],[11,R[10],E,E,4,[[["self"]],[T]]],[11,"drop",E,E,3,[[["self"]]]],[11,"drop",E,E,4,[[["self"]]]],[11,"new",E,"Creates a new `Once` value.",5,[[],["once"]]],[11,"call_once",E,"Performs an initialization routine once and only once. The given closure will be executed if this is the first time `call_once` has been called, and otherwise the routine will not be invoked.",5,[[["self"],["f"]],[T]]],[11,"try",E,"Returns a pointer iff the `Once` was previously initialized",5,[[["self"]],[R[4]]]],[11,"wait",E,"Like try, but will spin if the `Once` is in the process of being initialized",5,[[["self"]],[R[4]]]]],"paths":[[3,"Mutex"],[3,R[11]],[3,"RwLock"],[3,R[12]],[3,R[13]],[3,"Once"]]};
searchIndex[R[14]]={"doc":R[22],"i":[[3,R[21],R[14],R[23],N,N],[3,"Stats",E,R[24],N,N],[12,R[25],E,R[26],0,N],[12,R[27],E,R[28],0,N],[12,R[29],E,R[30],0,N],[12,R[31],E,R[32],0,N],[12,R[33],E,R[34],0,N],[12,R[35],E,R[36],0,N],[3,"Region",E,R[37],N,N],[7,R[38],E,R[39],N,N],[11,"system",E,R[40],1,[[],["self"]]],[11,"new",E,R[41],1,[[[T]],["self"]]],[11,"stats",E,R[42],1,[[["self"]],["stats"]]],[11,"new",E,R[43],2,[[[R[20]]],["self"]]],[11,"initial",E,R[44],2,[[["self"]],["stats"]]],[11,"change",E,R[15],2,[[["self"]],["stats"]]],[11,R[45],E,R[15],2,[[["self"]],["stats"]]],[11,"reset",E,R[46],2,[[["self"]]]],[11,"into",E,E,1,[[["self"]],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[16],E,E,1,[[[U]],[R[8]]]],[11,R[49],E,E,1,[[["self"]],[T]]],[11,R[19],E,E,1,[[["self"]],[R[50]]]],[11,R[17],E,E,1,[[["self"]],[T]]],[11,R[18],E,E,1,[[["self"]],[R[8]]]],[11,"into",E,E,0,[[["self"]],[U]]],[11,R[47],E,E,0,[[["self"]],[T]]],[11,R[48],E,E,0,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[16],E,E,0,[[[U]],[R[8]]]],[11,R[49],E,E,0,[[["self"]],[T]]],[11,R[19],E,E,0,[[["self"]],[R[50]]]],[11,R[17],E,E,0,[[["self"]],[T]]],[11,R[18],E,E,0,[[["self"]],[R[8]]]],[11,"into",E,E,2,[[["self"]],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[16],E,E,2,[[[U]],[R[8]]]],[11,R[49],E,E,2,[[["self"]],[T]]],[11,R[19],E,E,2,[[["self"]],[R[50]]]],[11,R[17],E,E,2,[[["self"]],[T]]],[11,R[18],E,E,2,[[["self"]],[R[8]]]],[11,R[9],E,E,1,[[],[R[20]]]],[11,R[9],E,E,0,[[],["stats"]]],[11,"eq",E,E,0,[[["self"],["stats"]],["bool"]]],[11,"ne",E,E,0,[[["self"],["stats"]],["bool"]]],[11,"clone",E,E,0,[[["self"]],["stats"]]],[11,"fmt",E,E,1,[[["self"],[R[7]]],[R[8]]]],[11,"fmt",E,E,0,[[["self"],[R[7]]],[R[8]]]],[11,"fmt",E,E,2,[[["self"],[R[7]]],[R[8]]]],[11,"sub",E,E,0,N],[11,R[51],E,E,0,[[["self"],["self"]]]],[11,"hash",E,E,0,N],[11,"alloc",E,E,1,N],[11,"dealloc",E,E,1,N],[11,R[52],E,E,1,N],[11,"realloc",E,E,1,N]],"p":[[3,"Stats"],[3,R[21]],[3,"Region"]]};
searchIndex[R[0]]={"doc":"A macro for declaring lazily evaluated statics.","items":[[5,"initialize",R[0],"Takes a shared reference to a lazy static and initializes it if it has not been already.",N,[[[T]]]],[8,"LazyStatic",E,"Support trait for enabling a few common operation on lazy static values.",N,N],[14,R[0],E,E,N,N]],"paths":[]};
searchIndex[R[14]]={"doc":R[22],"i":[[3,R[21],R[14],R[23],N,N],[3,"Stats",E,R[24],N,N],[12,R[25],E,R[26],0,N],[12,R[27],E,R[28],0,N],[12,R[29],E,R[30],0,N],[12,R[31],E,R[32],0,N],[12,R[33],E,R[34],0,N],[12,R[35],E,R[36],0,N],[3,"Region",E,R[37],N,N],[7,R[38],E,R[39],N,N],[11,"system",E,R[40],1,[[],["self"]]],[11,"new",E,R[41],1,[[[T]],["self"]]],[11,"stats",E,R[42],1,[[["self"]],["stats"]]],[11,"new",E,R[43],2,[[[R[20]]],["self"]]],[11,"initial",E,R[44],2,[[["self"]],["stats"]]],[11,"change",E,R[15],2,[[["self"]],["stats"]]],[11,R[45],E,R[15],2,[[["self"]],["stats"]]],[11,"reset",E,R[46],2,[[["self"]]]],[11,"into",E,E,1,[[["self"]],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[16],E,E,1,[[[U]],[R[8]]]],[11,R[49],E,E,1,[[["self"]],[T]]],[11,R[19],E,E,1,[[["self"]],[R[50]]]],[11,R[17],E,E,1,[[["self"]],[T]]],[11,R[18],E,E,1,[[["self"]],[R[8]]]],[11,"into",E,E,0,[[["self"]],[U]]],[11,R[47],E,E,0,[[["self"]],[T]]],[11,R[48],E,E,0,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[16],E,E,0,[[[U]],[R[8]]]],[11,R[49],E,E,0,[[["self"]],[T]]],[11,R[19],E,E,0,[[["self"]],[R[50]]]],[11,R[17],E,E,0,[[["self"]],[T]]],[11,R[18],E,E,0,[[["self"]],[R[8]]]],[11,"into",E,E,2,[[["self"]],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[16],E,E,2,[[[U]],[R[8]]]],[11,R[49],E,E,2,[[["self"]],[T]]],[11,R[19],E,E,2,[[["self"]],[R[50]]]],[11,R[17],E,E,2,[[["self"]],[T]]],[11,R[18],E,E,2,[[["self"]],[R[8]]]],[11,R[9],E,E,1,[[],[R[20]]]],[11,R[9],E,E,0,[[],["stats"]]],[11,"eq",E,E,0,[[["self"],["stats"]],["bool"]]],[11,"ne",E,E,0,[[["self"],["stats"]],["bool"]]],[11,"clone",E,E,0,[[["self"]],["stats"]]],[11,"fmt",E,E,1,[[["self"],[R[7]]],[R[8]]]],[11,"fmt",E,E,0,[[["self"],[R[7]]],[R[8]]]],[11,"fmt",E,E,2,[[["self"],[R[7]]],[R[8]]]],[11,"sub",E,E,0,N],[11,R[51],E,E,0,[[["self"],["self"]]]],[11,"hash",E,E,0,N],[11,"alloc",E,E,1,N],[11,"dealloc",E,E,1,N],[11,R[52],E,E,1,N],[11,"realloc",E,E,1,N]],"p":[[3,"Stats"],[3,R[21]],[3,"Region"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);