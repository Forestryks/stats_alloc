var N=null,E="",T="t",U="u",searchIndex={};
var R=["lazy_static","mutexguard","Creates a new spinlock wrapping the supplied data.","into_inner","option","rwlockreadguard","rwlockwriteguard","formatter","result","default","deref_mut","MutexGuard","RwLockReadGuard","RwLockWriteGuard","stats_alloc","Returns the difference between the currently reported…","try_from","borrow_mut","try_into","type_id","statsalloc","StatsAlloc"];

searchIndex[R[0]]={"doc":"A macro for declaring lazily evaluated statics.","items":[[5,"initialize",R[0],"Takes a shared reference to a lazy static and initializes it if it has not been already.",N,[[[T]]]],[8,"LazyStatic",E,"Support trait for enabling a few common operation on lazy static values.",N,N],[14,R[0],E,E,N,N]],"paths":[]};
searchIndex["spin"]={"doc":"Synchronization primitives based on spinning","items":[[3,"Mutex","spin","This type provides MUTual EXclusion based on spinning.",N,N],[3,R[11],E,"A guard to which the protected data can be accessed",N,N],[3,"RwLock",E,"A reader-writer lock",N,N],[3,R[12],E,"A guard to which the protected data can be read",N,N],[3,R[13],E,"A guard to which the protected data can be written",N,N],[3,"Once",E,"A synchronization primitive which can be used to run a one-time global initialization. Unlike its std equivalent, this is generalized so that The closure returns a value and it is stored. Once therefore acts something like 1a future, too.",N,N],[11,"new",E,R[2],0,[[[T]],["mutex"]]],[11,R[3],E,"Consumes this mutex, returning the underlying data.",0,[[["self"]],[T]]],[11,"lock",E,"Locks the spinlock and returns a guard.",0,[[["self"]],[R[1]]]],[11,"force_unlock",E,"Force unlock the spinlock.",0,[[["self"]]]],[11,"try_lock",E,"Tries to lock the mutex. If it is already locked, it will return None. Otherwise it returns a guard within Some.",0,[[["self"]],[R[4],[R[1]]]]],[11,"fmt",E,E,0,[[["self"],[R[7]]],[R[8]]]],[11,R[9],E,E,0,[[],["mutex"]]],[11,"deref",E,E,1,[[["self"]],[T]]],[11,R[10],E,E,1,[[["self"]],[T]]],[11,"drop",E,"The dropping of the MutexGuard will release the lock it was created from.",1,[[["self"]]]],[11,"new",E,R[2],2,[[[T]],["rwlock"]]],[11,R[3],E,"Consumes this `RwLock`, returning the underlying data.",2,[[["self"]],[T]]],[11,"read",E,"Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",2,[[["self"]],[R[5]]]],[11,"try_read",E,"Attempt to acquire this lock with shared read access.",2,[[["self"]],[R[4],[R[5]]]]],[11,"force_read_decrement",E,"Force decrement the reader count.",2,[[["self"]]]],[11,"force_write_unlock",E,"Force unlock exclusive write access.",2,[[["self"]]]],[11,"write",E,"Lock this rwlock with exclusive write access, blocking the current thread until it can be acquired.",2,[[["self"]],[R[6]]]],[11,"try_write",E,"Attempt to lock this rwlock with exclusive write access.",2,[[["self"]],[R[4],[R[6]]]]],[11,"fmt",E,E,2,[[["self"],[R[7]]],[R[8]]]],[11,R[9],E,E,2,[[],["rwlock"]]],[11,"deref",E,E,3,[[["self"]],[T]]],[11,"deref",E,E,4,[[["self"]],[T]]],[11,R[10],E,E,4,[[["self"]],[T]]],[11,"drop",E,E,3,[[["self"]]]],[11,"drop",E,E,4,[[["self"]]]],[11,"new",E,"Creates a new `Once` value.",5,[[],["once"]]],[11,"call_once",E,"Performs an initialization routine once and only once. The given closure will be executed if this is the first time `call_once` has been called, and otherwise the routine will not be invoked.",5,[[["self"],["f"]],[T]]],[11,"try",E,"Returns a pointer iff the `Once` was previously initialized",5,[[["self"]],[R[4]]]],[11,"wait",E,"Like try, but will spin if the `Once` is in the process of being initialized",5,[[["self"]],[R[4]]]]],"paths":[[3,"Mutex"],[3,R[11]],[3,"RwLock"],[3,R[12]],[3,R[13]],[3,"Once"]]};
searchIndex[R[14]]={"doc":"An instrumenting middleware for global allocators in Rust,…","i":[[3,R[21],R[14],"An instrumenting middleware which keeps track of…",N,N],[3,"Stats",E,"Allocator statistics",N,N],[12,"allocations",E,"Count of allocation operations",0,N],[12,"deallocations",E,"Count of deallocation operations",0,N],[12,"reallocations",E,"Count of reallocation operations",0,N],[12,"bytes_allocated",E,"Total bytes requested by allocations",0,N],[12,"bytes_deallocated",E,"Total bytes freed by deallocations",0,N],[12,"bytes_reallocated",E,"Total of bytes requested minus bytes freed by reallocations",0,N],[3,"Region",E,"A snapshot of the allocation statistics, which can be used…",N,N],[7,"INSTRUMENTED_SYSTEM",E,"An instrumented instance of the system allocator.",N,N],[11,"system",E,"Provides access to an instrumented instance of the system…",1,[[],["self"]]],[11,"new",E,"Provides access to an instrumented instance of the given…",1,[[[T]],["self"]]],[11,"stats",E,"Takes a snapshot of the current view of the allocator…",1,[[["self"]],["stats"]]],[11,"new",E,"Creates a new region using statistics from the given…",2,[[[R[20]]],["self"]]],[11,"initial",E,"Returns the statistics as of instantiation or the last…",2,[[["self"]],["stats"]]],[11,"change",E,R[15],2,[[["self"]],["stats"]]],[11,"change_and_reset",E,R[15],2,[[["self"]],["stats"]]],[11,"reset",E,"Resets the initial initial to the latest reported…",2,[[["self"]]]],[11,"into",E,E,1,[[["self"]],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[16],E,E,1,[[[U]],[R[8]]]],[11,"borrow",E,E,1,[[["self"]],[T]]],[11,R[19],E,E,1,[[["self"]],["typeid"]]],[11,R[17],E,E,1,[[["self"]],[T]]],[11,R[18],E,E,1,[[["self"]],[R[8]]]],[11,"into",E,E,0,[[["self"]],[U]]],[11,"to_owned",E,E,0,[[["self"]],[T]]],[11,"clone_into",E,E,0,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[16],E,E,0,[[[U]],[R[8]]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,R[19],E,E,0,[[["self"]],["typeid"]]],[11,R[17],E,E,0,[[["self"]],[T]]],[11,R[18],E,E,0,[[["self"]],[R[8]]]],[11,"into",E,E,2,[[["self"]],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[16],E,E,2,[[[U]],[R[8]]]],[11,"borrow",E,E,2,[[["self"]],[T]]],[11,R[19],E,E,2,[[["self"]],["typeid"]]],[11,R[17],E,E,2,[[["self"]],[T]]],[11,R[18],E,E,2,[[["self"]],[R[8]]]],[11,R[9],E,E,1,[[],[R[20]]]],[11,R[9],E,E,0,[[],["stats"]]],[11,"eq",E,E,0,[[["self"],["stats"]],["bool"]]],[11,"ne",E,E,0,[[["self"],["stats"]],["bool"]]],[11,"clone",E,E,0,[[["self"]],["stats"]]],[11,"fmt",E,E,1,[[["self"],[R[7]]],[R[8]]]],[11,"fmt",E,E,0,[[["self"],[R[7]]],[R[8]]]],[11,"fmt",E,E,2,[[["self"],[R[7]]],[R[8]]]],[11,"sub",E,E,0,N],[11,"sub_assign",E,E,0,[[["self"],["self"]]]],[11,"hash",E,E,0,N],[11,"alloc",E,E,1,N],[11,"dealloc",E,E,1,N],[11,"alloc_zeroed",E,E,1,N],[11,"realloc",E,E,1,N]],"p":[[3,"Stats"],[3,R[21]],[3,"Region"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);